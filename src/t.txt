// src/App.jsx
import React from 'react';
import { Toaster } from "@/components/ui/toaster";
import { Toaster as Sonner } from "@/components/ui/sonner";
import { TooltipProvider } from "@/components/ui/tooltip";
import { QueryClient, QueryClientProvider } from "@tanstack/react-query";
import { BrowserRouter, Routes, Route } from "react-router-dom";
import Index from "./pages/Index";
import NotFound from "./pages/NotFound";

const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      refetchOnWindowFocus: false,
      retry: false,
    },
  },
});

const App = () => {
  return (
    <React.StrictMode>
      <QueryClientProvider client={queryClient}>
        <TooltipProvider>
          <BrowserRouter>
            <Toaster />
            <Sonner />
            <Routes>
              <Route path="/" element={<Index />} />
              <Route path="*" element={<NotFound />} />
            </Routes>
          </BrowserRouter>
        </TooltipProvider>
      </QueryClientProvider>
    </React.StrictMode>
  );
};

export default App;

###############################################################"


import { create } from 'zustand';

type Highlight = {
  id: string;
  text: string;
  color: string;
  createdAt: Date;
};



type HighlightStore = {
  highlights: Highlight[];
  addHighlight: (highlight: Omit<Highlight, 'id' | 'createdAt'>) => void;
  removeHighlight: (id: string) => void;
  clearHighlights: () => void;
};

export const useHighlightStore = create<HighlightStore>((set) => ({
  highlights: [],
  addHighlight: (highlight) =>
    set((state) => ({
      highlights: [
        ...state.highlights,
        {
          ...highlight,
          id: crypto.randomUUID(),
          createdAt: new Date(),
        },
      ],
    })),
  removeHighlight: (id) =>
    set((state) => ({
      highlights: state.highlights.filter((h) => h.id !== id),
    })),
  clearHighlights: () => set({ highlights: [] }),
}));


#############################################


import Elk from 'elkjs/lib/elk.bundled.js';
import { Node, Edge } from '@xyflow/react';

export interface Position {
  x: number;
  y: number;
}

export interface Size {
  width: number;
  height: number;
}

export async function elkLayout(nodes: Node[], edges: Edge[]) {
  const elk = new Elk({
    defaultLayoutOptions: {
      'elk.algorithm': 'layered',
      'elk.direction': 'RIGHT',
      'elk.spacing.nodeNode': 100,
      'elk.layered.spacing.nodeNodeBetweenLayers': 150,
    },
  });

  const graph = await elk.layout({
    id: 'root',
    children: nodes.map(node => ({
      id: node.id,
      width: 240,
      height: node.data.type === 'event' ? 160 : 120,
    })),
    edges: edges.map(edge => ({
      id: edge.id,
      sources: [edge.source],
      targets: [edge.target],
    })),
  });

  return nodes.map(node => {
    const elkNode = graph.children?.find(n => n.id === node.id);
    return {
      ...node,
      position: { x: elkNode?.x || 0, y: elkNode?.y || 0 },
    };
  });
}


########################################################################


import { create } from 'zustand';

interface Highlight {
  id: string;
  text: string;
  from: number;
  to: number;
}

interface HighlightStore {
  highlights: Highlight[];
  addHighlight: (highlight: Highlight) => void;
  removeHighlight: (id: string) => void;
  clearHighlights: () => void;
}

export const useHighlightStore = create<HighlightStore>((set, get) => ({
  highlights: [],
  addHighlight: (highlight) => {
    set((state) => ({
      highlights: [...state.highlights, highlight],
    }));
    localStorage.setItem('highlights', JSON.stringify(get().highlights));
  },
  removeHighlight: (id) => {
    set((state) => ({
      highlights: state.highlights.filter((h) => h.id !== id),
    }));
    localStorage.setItem('highlights', JSON.stringify(get().highlights));
  },
  clearHighlights: () => {
    set({ highlights: [] });
    localStorage.removeItem('highlights');
  },
}));

######################################################################



import { Node } from '@xyflow/react';
import { HistoricalNodeData } from '../components/HistoricalNode';

export const getNodePosition = (nodes: Node[]): { x: number; y: number } => {
  if (nodes.length === 0) return { x: 100, y: 100 };

  const lastNode = nodes[nodes.length - 1];
  return {
    x: lastNode.position.x + 250,
    y: lastNode.position.y,
  };
};

export const getNodesBounds = (nodes: Node[]): { x: number; y: number; width: number; height: number } => {
  if (nodes.length === 0) {
    return { x: 0, y: 0, width: 0, height: 0 };
  }

  let minX = Infinity;
  let minY = Infinity;
  let maxX = -Infinity;
  let maxY = -Infinity;

  nodes.forEach((node) => {
    const x = node.position.x;
    const y = node.position.y;
    const width = node.width || 240;
    const height = node.height || 100;
    minX = Math.min(minX, x);
    minY = Math.min(minY, y);
    maxX = Math.max(maxX, x + width);
    maxY = Math.max(maxY, y + height);
  });

  const padding = 50;
  return {
    x: minX - padding,
    y: minY - padding,
    width: maxX - minX + 2 * padding,
    height: maxY - minY + 2 * padding,
  };
};



##########################################################################################################"



import { useQuery } from '@tanstack/react-query';

interface Entity {
  text: string;
  type: 'event' | 'person' | 'cause' | 'political' | 'economic' | 'social' | 'cultural';
  relatedTo?: string[];
}

interface EntityAnalysisResponse {
  entities: Entity[];
  relationships: Array<{
    source: string;
    target: string;
    type: string;
  }>;
}

const SYSTEM_PROMPT = `You are an AI assistant that analyzes historical texts in Arabic.
Your task is to:
1. Identify key entities (events, people, causes, and PESC factors)
2. Classify each entity into one of these types: event, person, cause, political, economic, social, cultural
3. Identify relationships between entities

Return the response in this exact JSON format:
{
  "entities": [
    { "text": "entity text", "type": "type of entity", "relatedTo": ["related entity texts"] }
  ],
  "relationships": [
    { "source": "source entity text", "target": "target entity text", "type": "relationship type" }
  ]
}`;

export async function analyzeText(text: string): Promise<EntityAnalysisResponse> {
  const response = await fetch('https://generativelanguage.googleapis.com/v1beta/models/gemini-pro:generateContent', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'Authorization': `Bearer ${process.env.GEMINI_API_KEY}`
    },
    body: JSON.stringify({
      contents: [{
        parts: [{
          text: `${SYSTEM_PROMPT}\n\nText to analyze: ${text}`
        }]
      }]
    })
  });

  if (!response.ok) {
    const errorText = await response.text();
    console.error(`Gemini API error: ${response.status} - ${errorText}`);
    throw new Error(`Failed to analyze text: ${response.status} - ${errorText}`);
  }

  const data = await response.json();
  try {
    const result = JSON.parse(data.candidates[0].content.parts[0].text);
    return result;
  } catch (error) {
    console.error('Error parsing Gemini response:', error);
    throw new Error('Failed to parse analysis results');
  }
}

export function useTextAnalysis(text: string) {
  return useQuery({
    queryKey: ['textAnalysis', text],
    queryFn: () => analyzeText(text),
    enabled: !!text && text.length > 0,
  });
}


###################################################################################

'use client';

import { useCallback, useEffect, useState, useRef } from "react";
import { useEditor, EditorContent } from "@tiptap/react";
import StarterKit from "@tiptap/starter-kit";
import { Card } from "@/components/ui/card";
import { ScrollArea } from "@/components/ui/scroll-area";
import { Separator } from "@/components/ui/separator";
import { Button } from "@/components/ui/button";
import { useTextAnalysis } from "../services/geminiService";
import { useToast } from "@/components/ui/use-toast";
import debounce from 'lodash/debounce'; // Ensure lodash is installed

export default function Analysis() {
  const [isReady, setIsReady] = useState(false);
  const [content, setContent] = useState('');
  const { toast } = useToast();
  const { data: analysis, isLoading, error } = useTextAnalysis(content);

  const editor = useEditor({
    onCreate: () => setIsReady(true), // Editor is now fully created
    extensions: [StarterKit],
    content: `<h2>مرحباً بك في نظام تحليل النصوص التاريخية</h2>
<p>ابدأ بنسخ النص التاريخي هنا. ثم انقر على زر التحليل لاكتشاف العلاقات والكيانات التاريخية.</p>`,
    editorProps: {
      attributes: {
        class: 'outline-none',
        dir: 'rtl',
      },
    },
    onUpdate: ({ editor }) => {
      debouncedSetContent(editor.getText());
    },
  });

  const debouncedSetContent = useRef(debounce((text) => {
    setContent(text);
  }, 500)).current;



  useEffect(() => {
    if (analysis && !isLoading && !error) {
      const event = new CustomEvent('analysisResults', { detail: analysis });
      window.dispatchEvent(event);

      toast({
        title: "تم التحليل بنجاح",
        description: "تم اكتشاف العلاقات والكيانات التاريخية.",
      });
    }
  }, [analysis, isLoading, error, toast]);

  useEffect(() => {
    if (error) {
      toast({
        variant: "destructive",
        title: "خطأ في التحليل",
        description: "حدث خطأ أثناء تحليل النص. يرجى المحاولة مرة أخرى.",
      });
    }
  }, [error, toast]);


  return (
    <div className="flex h-screen bg-background" dir="rtl">
      <div className="flex-1 flex flex-col p-6">
        <div className="flex justify-between items-center mb-6">
          <h1 className="text-3xl font-bold">تحليل النص التاريخي</h1>
          <Button
            onClick={() => setContent(editor?.getText() || '')}
            disabled={isLoading || !isReady}
          >
            {isLoading ? 'جاري التحليل...' : 'تحليل النص'}
          </Button>
        </div>

        <Card className="flex-1 p-6">
          {!editor ? (
            <div className="h-full flex items-center justify-center">
              <p className="text-muted-foreground">جاري تحميل المحرر...</p>
            </div>
          ) : !isReady ? (
            <div className="h-full flex items-center justify-center">
              <p className="text-muted-foreground">جاري تهيئة المحرر...</p>
            </div>
          ) : (
            <EditorContent
              editor={editor}
              className="prose prose-sm max-w-none h-full [&_.ProseMirror]:h-full [&_.ProseMirror]:outline-none"
            />
          )}
        </Card>
      </div>

      <div className="w-80 border-r bg-muted/10 p-6">
        <h2 className="font-semibold mb-4">نتائج التحليل</h2>
        <Separator className="mb-4" />
        <ScrollArea className="h-[calc(100vh-10rem)]">
          {isLoading ? (
            <p className="text-sm text-muted-foreground">جاري تحليل النص...</p>
          ) : !analysis ? (
            <p className="text-sm text-muted-foreground">
              اكتب نصاً في المحرر واضغط على زر التحليل لرؤية النتائج.
            </p>
          ) : !analysis.entities || analysis.entities.length === 0 ? (
            <p className="text-sm text-muted-foreground">
              لم يتم العثور على نتائج.
            </p>
          ) : (
            <div className="space-y-4">
              {analysis.entities.map((entity, index) => (
                <Card key={index} className="p-4">
                  <div className="flex flex-col gap-2">
                    <p className="text-sm font-medium">{entity.text}</p>
                    <p className="text-xs text-muted-foreground">النوع: {entity.type}</p>
                    {entity.relatedTo && entity.relatedTo.length > 0 && (
                      <div className="text-xs">
                        <p className="text-muted-foreground">مرتبط بـ:</p>
                        <ul className="list-disc list-inside">
                          {entity.relatedTo.map((related, idx) => (
                            <li key={idx}>{related}</li>
                          ))}
                        </ul>
                      </div>
                    )}
                  </div>
                </Card>
              ))}
            </div>
          )}
        </ScrollArea>
      </div>
    </div>
  );
}

###################################################################################"""


'use client';

import { useCallback, useState, useEffect } from 'react';
import '@xyflow/react/dist/style.css';
import {
  ReactFlow,
  ReactFlowProvider,
  EdgeTypes,
  MarkerType,
  Background,
  Controls,
  Edge,
  Node,
  NodeChange,
  Connection,
  EdgeChange,
  applyNodeChanges,
  applyEdgeChanges,
  getViewportForBounds,
  useReactFlow,
} from '@xyflow/react';
import { toPng } from 'html-to-image';
import { jsPDF } from 'jspdf';
import HistoricalNode, { NodeType, HistoricalNodeData } from '../components/HistoricalNode';
import { HistoricalEdge, HistoricalEdgeData } from '../components/HistoricalEdge';
import { EdgeDialog } from './EdgeDialog';
import { getNodePosition, getNodesBounds } from '../utils/flowUtils';
import { useHighlightStore } from '../utils/highlightStore';
import { LeftPanel } from '../components/flow/LeftPanel';
import { RightPanel } from '../components/flow/RightPanel';

const edgeTypes: EdgeTypes = {
  historical: HistoricalEdge,
};

const defaultEdgeOptions = {
  type: 'historical' as const,
  markerEnd: {
    type: MarkerType.ArrowClosed,
    width: 20,
    height: 20,
  },
};

const nodeTypes = {
  historical: HistoricalNode,
};

const initialNodes: Node<HistoricalNodeData>[] = [];
const initialEdges: Edge<HistoricalEdgeData>[] = [];

const FlowContent = () => {
  const [isMounted, setIsMounted] = useState(false);
  const [nodes, setNodes] = useState<Node<HistoricalNodeData>[]>(initialNodes);
  const [edges, setEdges] = useState<Edge<HistoricalEdgeData>[]>(initialEdges);
  const [isEdgeDialogOpen, setIsEdgeDialogOpen] = useState(false);
  const [edgeSourceNode, setEdgeSourceNode] = useState<string | null>(null);
  const [edgeTargetNode, setEdgeTargetNode] = useState<string | null>(null);

  const { highlights, removeHighlight } = useHighlightStore();
  const { setViewport } = useReactFlow();

  useEffect(() => {
    setIsMounted(true);
  }, []);

  useEffect(() => {
    const handleNodeUpdate = (event: Event) => {
      const customEvent = event as CustomEvent<{ id: string; data: HistoricalNodeData }>;
      const { id, data } = customEvent.detail;
      setNodes((nds) =>
        nds.map((node) => (node.id === id ? { ...node, data } : node))
      );
    };

    window.addEventListener('updateNodeData', handleNodeUpdate);
    return () => window.removeEventListener('updateNodeData', handleNodeUpdate);
  }, []);

  const fitView = useCallback(() => {
    if (nodes.length === 0) return;
    const bounds = getNodesBounds(nodes);
    const viewport = getViewportForBounds(
      bounds,
      window.innerWidth,
      window.innerHeight,
      0.5,
      2
    );
    setViewport(viewport);
  }, [nodes, setViewport]);
  const downloadAsPDF = useCallback(() => {
    if (nodes.length === 0) return;
  
    const flowElement = document.querySelector('.react-flow') as HTMLElement | null;
    if (!flowElement) return;
  
    // Get the flow wrapper element
    const flowWrapper = flowElement.querySelector('.react-flow__viewport') as HTMLElement | null;
    if (!flowWrapper) return;
  
    // Calculate the bounds of all nodes
    const nodesBounds = getNodesBounds(nodes);
    const padding = 50;
    const width = nodesBounds.width + (padding * 2);
    const height = nodesBounds.height + (padding * 2);
  
    // Save current styles
    const currentTransform = flowWrapper.style.transform;
    const currentWidth = flowWrapper.style.width;
    const currentHeight = flowWrapper.style.height;
  
    // Temporarily modify the wrapper
    flowWrapper.style.width = `${width}px`;
    flowWrapper.style.height = `${height}px`;
    flowWrapper.style.transform = 'translate(0,0) scale(1)';
  
    toPng(flowWrapper, {
      backgroundColor: '#ffffff',
      width,
      height,
      style: {
        width: `${width}px`,
        height: `${height}px`,
      },
      filter: (node) => {
        // Only include nodes and edges
        return (
          node.classList?.contains('react-flow__node') ||
          node.classList?.contains('react-flow__edge') ||
          node.classList?.contains('react-flow__edge-path') ||
          node.classList?.contains('react-flow__connection-path')
        );
      }
    })
    .then((dataUrl) => {
      const pdf = new jsPDF({
        orientation: width > height ? 'landscape' : 'portrait',
        unit: 'px',
        format: [width, height]
      });
      
      pdf.addImage(dataUrl, 'PNG', padding, padding, width - (padding * 2), height - (padding * 2));
      pdf.save('historical-flow.pdf');
  
      // Restore original styles
      flowWrapper.style.transform = currentTransform;
      flowWrapper.style.width = currentWidth;
      flowWrapper.style.height = currentHeight;
    });
  }, [nodes]);

  const onNodesChange = useCallback(
    (changes: NodeChange[]) => setNodes((nds) => applyNodeChanges(changes, nds)),
    []
  );

  const onEdgesChange = useCallback(
    (changes: EdgeChange[]) => setEdges((eds) => applyEdgeChanges(changes, eds)),
    []
  );

  const onConnect = useCallback((params: Connection) => {
    if (params.source && params.target) {
      setEdgeSourceNode(params.source);
      setEdgeTargetNode(params.target);
      setIsEdgeDialogOpen(true);
    }
  }, []);

  const handleEdgeComplete = useCallback(
    (type: string, customLabel?: string) => {
      if (!edgeSourceNode || !edgeTargetNode) return;
      const edgeId = `e${edgeSourceNode}-${edgeTargetNode}`;
      const newEdge: Edge<HistoricalEdgeData> = {
        id: edgeId,
        source: edgeSourceNode,
        target: edgeTargetNode,
        type: 'historical',
        data: { type, customLabel },
        animated: true,
      };
      setEdges((eds) => [...eds, newEdge]);
      setEdgeSourceNode(null);
      setEdgeTargetNode(null);
      setIsEdgeDialogOpen(false);
    },
    [edgeSourceNode, edgeTargetNode]
  );

  const createNodeFromHighlight = useCallback(
    (highlight: { id: string; text: string }, type: NodeType) => {
      const position = getNodePosition(nodes);
      const newNode: Node<HistoricalNodeData> = {
        id: highlight.id,
        type: 'historical',
        position,
        data: { type, label: highlight.text, description: '' },
      };
      setNodes((nds) => [...nds, newNode]);
      removeHighlight(highlight.id);
    },
    [nodes, removeHighlight]
  );

  const addNode = useCallback(
    (type: NodeType) => {
      const newNode: Node<HistoricalNodeData> = {
        id: `${Date.now()}`,
        type: 'historical',
        position: getNodePosition(nodes),
        data: { type, label: `New ${type}`, description: `Description for new ${type}` },
      };
      setNodes((nds) => [...nds, newNode]);
    },
    [nodes]
  );

  if (!isMounted) return null;

  return (
    <div className="h-screen w-full">
      <ReactFlow
        nodes={nodes}
        edges={edges}
        onNodesChange={onNodesChange}
        onEdgesChange={onEdgesChange}
        onConnect={onConnect}
        nodeTypes={nodeTypes}
        edgeTypes={edgeTypes}
        defaultEdgeOptions={defaultEdgeOptions}
        fitView
      >
        <Background />
        <Controls />
        <LeftPanel
          onFitView={fitView}
          onDownloadPDF={downloadAsPDF}
          onAddNode={addNode}
        />
        <RightPanel
          highlights={highlights}
          onCreateNodeFromHighlight={createNodeFromHighlight}
        />
      </ReactFlow>
      <EdgeDialog
        isOpen={isEdgeDialogOpen}
        onClose={() => setIsEdgeDialogOpen(false)}
        onConfirm={handleEdgeComplete}
        defaultType="related-to"
      />
    </div>
  );
};

export default function Flow() {
  return (
    <ReactFlowProvider>
      <FlowContent />
    </ReactFlowProvider>
  );
}












import React, { useState } from 'react';
import { Label } from '@/components/ui/label';
import { Button } from '@/components/ui/button';
import { Dialog, DialogContent, DialogHeader, DialogTitle } from '@/components/ui/dialog';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';

interface EdgeDialogProps {
  isOpen: boolean;
  onClose: () => void;
  onConfirm: (type: string, customLabel?: string) => void;
  defaultType?: string;
  defaultLabel?: string;
}

export function EdgeDialog({ isOpen, onClose, onConfirm, defaultType = 'related-to', defaultLabel }: EdgeDialogProps) {
  const [customLabel, setCustomLabel] = useState<string | undefined>(defaultLabel);
  const [selectedType, setSelectedType] = useState<string>(defaultType);

  const handleConfirm = () => {
    onConfirm(selectedType, customLabel);
    onClose();
  };

  return (
    <Dialog open={isOpen} onOpenChange={onClose}>
      <DialogContent>
        <DialogHeader>
          <DialogTitle>Select Relationship Type</DialogTitle>
        </DialogHeader>
        <div className="space-y-4">
          <div className="space-y-2">
            <Label>Relationship Type</Label>
            <Select defaultValue={defaultType} onValueChange={(value) => setSelectedType(value)}>
              <SelectTrigger>
                <SelectValue placeholder="Choose relationship type" />
              </SelectTrigger>
              <SelectContent>
                {relationshipTypes.map((type) => (
                  <SelectItem key={type} value={type.toLowerCase().replace(/ /g, '-')}>
                    {type}
                  </SelectItem>
                ))}
              </SelectContent>
            </Select>
          </div>

          <div className="space-y-2">
            <Label>Custom Label (Optional)</Label>
            <input
              type="text"
              className="w-full px-3 py-2 border rounded-md"
              placeholder="Enter custom label"
              value={customLabel || ''}
              onChange={(e) => setCustomLabel(e.target.value)}
              onKeyDown={(e) => {
                if (e.key === 'Enter') {
                  handleConfirm();
                }
              }}
            />
          </div>
          <Button onClick={handleConfirm}>Confirm</Button>
        </div>
      </DialogContent>
    </Dialog>
  );
}

const relationshipTypes = [
  'Caused by',
  'Led to',
  'Influenced',
  'Part of',
  'Opposed to',
  'Related to',
];















import { useState, useCallback } from 'react';
import { Node, Edge } from '@xyflow/react';
import Analysis from './Analysis';
import Flow from './Flow';


export default function HomePage() {
  return (
    <div dir="rtl" className="grid grid-cols-2 gap-4 p-4">
      <div>
        <Analysis />
      </div>
      <div>
        <Flow />
      </div>
    </div>
  );
}
















import { Button } from '@/components/ui/button';
import { Card } from '@/components/ui/card';
import { Download, ZoomIn } from 'lucide-react';
import { Panel } from '@xyflow/react';
import { NodeType } from '../HistoricalNode';

interface LeftPanelProps {
  onFitView: () => void;
  onDownloadPDF: () => void;
  onAddNode: (type: NodeType) => void;
}

export function LeftPanel({ onFitView, onDownloadPDF, onAddNode }: LeftPanelProps) {
  return (
    <>
      <Panel position="top-left" className="bg-background/50 backdrop-blur-sm p-2 rounded-lg">
        <div className="flex gap-2">
          <Button variant="outline" size="sm" onClick={onFitView} className="flex items-center gap-2">
            <ZoomIn size={16} />
            Fit View
          </Button>
          <Button variant="outline" size="sm" onClick={onDownloadPDF} className="flex items-center gap-2">
            <Download size={16} />
            حفظ كـ PDF
          </Button>
        </div>
      </Panel>
      <Panel position="top-left" className="bg-background/50 backdrop-blur-sm p-2 rounded-lg">
        <div className="flex flex-col gap-2">
          <Button
            variant="outline"
            size="sm"
            onClick={() => onAddNode('event')}
            className="bg-blue-50 hover:bg-blue-100"
          >
            Add Event
          </Button>
          <Button
            variant="outline"
            size="sm"
            onClick={() => onAddNode('person')}
            className="bg-green-50 hover:bg-green-100"
          >
            Add Person
          </Button>
          <Button
            variant="outline"
            size="sm"
            onClick={() => onAddNode('cause')}
            className="bg-red-50 hover:bg-red-100"
          >
            Add Cause
          </Button>
          <Card className="p-2">
            <p className="text-xs font-medium mb-2">PESC Factors</p>
            <div className="flex flex-col gap-2">
              <Button
                variant="outline"
                size="sm"
                onClick={() => onAddNode('political')}
                className="bg-purple-50 hover:bg-purple-100"
              >
                Political
              </Button>
              <Button
                variant="outline"
                size="sm"
                onClick={() => onAddNode('economic')}
                className="bg-yellow-50 hover:bg-yellow-100"
              >
                Economic
              </Button>
              <Button
                variant="outline"
                size="sm"
                onClick={() => onAddNode('social')}
                className="bg-pink-50 hover:bg-pink-100"
              >
                Social
              </Button>
              <Button
                variant="outline"
                size="sm"
                onClick={() => onAddNode('cultural')}
                className="bg-indigo-50 hover:bg-indigo-100"
              >
                Cultural
              </Button>
            </div>
          </Card>
        </div>
      </Panel>
    </>
  );
}














import { Card } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { Panel } from '@xyflow/react';
import { NodeType } from '../HistoricalNode';

interface Highlight {
  id: string;
  text: string;
}

interface RightPanelProps {
  highlights: Highlight[];
  onCreateNodeFromHighlight: (highlight: Highlight, type: NodeType) => void;
}

export function RightPanel({ highlights, onCreateNodeFromHighlight }: RightPanelProps) {
  return (
    <Panel position="top-right" className="bg-background/50 backdrop-blur-sm p-4 rounded-lg w-80">
      <div className="space-y-4">
        <h3 className="font-semibold">Highlighted Passages</h3>
        {highlights.length === 0 ? (
          <p className="text-sm text-muted-foreground">
            No highlights available. Select text in the Analysis page to create nodes.
          </p>
        ) : (
          <div className="space-y-3">
            {highlights.map((highlight) => (
              <Card key={highlight.id} className="p-3">
                <p className="text-sm mb-2">{highlight.text}</p>
                <div className="space-y-2">
                  <div className="flex flex-wrap gap-2">
                    <Button
                      size="sm"
                      variant="outline"
                      className="bg-blue-50 hover:bg-blue-100"
                      onClick={() => onCreateNodeFromHighlight(highlight, 'event')}
                    >
                      Event
                    </Button>
                    <Button
                      size="sm"
                      variant="outline"
                      className="bg-green-50 hover:bg-green-100"
                      onClick={() => onCreateNodeFromHighlight(highlight, 'person')}
                    >
                      Person
                    </Button>
                    <Button
                      size="sm"
                      variant="outline"
                      className="bg-red-50 hover:bg-red-100"
                      onClick={() => onCreateNodeFromHighlight(highlight, 'cause')}
                    >
                      Cause
                    </Button>
                  </div>
                  <div className="flex flex-wrap gap-2">
                    <Button
                      size="sm"
                      variant="outline"
                      className="bg-purple-50 hover:bg-purple-100"
                      onClick={() => onCreateNodeFromHighlight(highlight, 'political')}
                    >
                      Political
                    </Button>
                    <Button
                      size="sm"
                      variant="outline"
                      className="bg-yellow-50 hover:bg-yellow-100"
                      onClick={() => onCreateNodeFromHighlight(highlight, 'economic')}
                    >
                      Economic
                    </Button>
                    <Button
                      size="sm"
                      variant="outline"
                      className="bg-pink-50 hover:bg-pink-100"
                      onClick={() => onCreateNodeFromHighlight(highlight, 'social')}
                    >
                      Social
                    </Button>
                    <Button
                      size="sm"
                      variant="outline"
                      className="bg-indigo-50 hover:bg-indigo-100"
                      onClick={() => onCreateNodeFromHighlight(highlight, 'cultural')}
                    >
                      Cultural
                    </Button>
                  </div>
                </div>
              </Card>
            ))}
          </div>
        )}
      </div>
    </Panel>
  );
}












interface ColorPickerProps {
    value: string; // Assuming string for hex color
    onChange: (color: string) => void;
  }
  
  export function ColorPicker({ value, onChange }: ColorPickerProps) {
    const colors: string[] = ['#FFEB3B', '#90CAF9', '#A5D6A7', '#FFF59D', '#CE93D8'];
  
    return (
      <div className="flex gap-2 p-2 bg-background rounded-lg">
        {colors.map((color) => (
          <button
            key={color}
            className={`h-8 w-8 rounded-full border-2 transition-all ${
              color === value ? 'scale-110 shadow-lg' : 'scale-100'
            }`}
            style={{ backgroundColor: color }}
            onClick={() => onChange(color)}
          />
        ))}
      </div>
    );
  }








  
import { BaseEdge, EdgeLabelRenderer, EdgeProps, getBezierPath } from '@xyflow/react';

export interface HistoricalEdgeData extends Record<string, unknown> {
  type: string;
  customLabel?: string;
}

export function HistoricalEdge({
  id,
  sourceX,
  sourceY,
  targetX,
  targetY,
  sourcePosition,
  targetPosition,
  style = {},
  markerEnd,
  data,
}: EdgeProps<HistoricalEdgeData>) {
  const [edgePath, labelX, labelY] = getBezierPath({
    sourceX,
    sourceY,
    sourcePosition,
    targetX,
    targetY,
    targetPosition,
  });

  return (
    <>
      <BaseEdge path={edgePath} markerEnd={markerEnd} style={style} />
      <EdgeLabelRenderer>
        <div
          style={{
            position: 'absolute',
            transform: `translate(-50%, -50%) translate(${labelX}px,${labelY}px)`,
            pointerEvents: 'all',
          }}
          className="nodrag nopan"
        >
          <div className="px-2 py-1 bg-white rounded shadow-sm border text-sm">
            {data?.customLabel || data?.type || 'connected'}
          </div>
        </div>
      </EdgeLabelRenderer>
    </>
  );
}












'use client';

import { useState, useCallback, useRef, useEffect } from 'react';
import { Handle, Position } from '@xyflow/react';
import { Card } from '@/components/ui/card';
import { Input } from '@/components/ui/input';
import { Textarea } from '@/components/ui/textarea';
import { Button } from '@/components/ui/button';
import { Dialog, DialogContent, DialogHeader, DialogTitle } from '@/components/ui/dialog';

// Define possible node types
export type NodeType = 'event' | 'person' | 'cause' | 'political' | 'economic' | 'social' | 'cultural';

// Interface for node data
export interface HistoricalNodeData extends Record<string, unknown> {
  label: string;
  type: NodeType;
  description?: string;
}

// Props interface for the component
interface Props {
  data: HistoricalNodeData;
  isConnectable: boolean;
  id: string;
  selected: boolean;
}

// Icons for each node type
const typeIcons: Record<NodeType, string> = {
  event: '📅',
  person: '👤',
  cause: '⚡',
  political: '🏛️',
  economic: '💰',
  social: '👥',
  cultural: '🎭',
};

// Labels for each node type (in Arabic)
const typeLabels: Record<NodeType, string> = {
  event: 'حدث',
  person: 'شخصية',
  cause: 'سبب',
  political: 'سياسي',
  economic: 'اقتصادي',
  social: 'اجتماعي',
  cultural: 'ثقافي',
};

// Colors for each node type
const typeColors: Record<NodeType, { bg: string; border: string }> = {
  event: { bg: 'bg-blue-50', border: 'border-blue-200' },
  person: { bg: 'bg-green-50', border: 'border-green-200' },
  cause: { bg: 'bg-red-50', border: 'border-red-200' },
  political: { bg: 'bg-purple-50', border: 'border-purple-200' },
  economic: { bg: 'bg-yellow-50', border: 'border-yellow-200' },
  social: { bg: 'bg-pink-50', border: 'border-pink-200' },
  cultural: { bg: 'bg-indigo-50', border: 'border-indigo-200' },
};

// HistoricalNode component
export default function HistoricalNode({ data, isConnectable, id, selected }: Props) {
  const [isDialogOpen, setIsDialogOpen] = useState(false);
  const [editedData, setEditedData] = useState<HistoricalNodeData>(data);
  const prevOpen = useRef(false);

  // Reset editedData when the dialog opens
  useEffect(() => {
    if (!prevOpen.current && isDialogOpen) {
      setEditedData(data);
    }
    prevOpen.current = isDialogOpen;
  }, [isDialogOpen, data]);

  // Handle double-click to open the dialog
  const handleDoubleClick = useCallback((event: React.MouseEvent) => {
    event.stopPropagation();
    setIsDialogOpen(true);
  }, []);

  // Handle saving edited data
  const handleSave = useCallback(() => {
    const event = new CustomEvent('updateNodeData', {
      detail: { id, data: editedData },
    });
    window.dispatchEvent(event);
    setIsDialogOpen(false);
  }, [id, editedData]);

  // Check if data is provided
  if (!data) {
    return <div>خطأ: لم يتم توفير البيانات</div>;
  }

  const { type, label, description } = data;
  const colors = typeColors[type] || { bg: 'bg-gray-50', border: 'border-gray-200' };

  return (
    <>
      <Card
        className={`w-60 shadow-sm ${colors.bg} ${colors.border} border-2 ${selected ? 'ring-2 ring-blue-500' : ''}`}
        dir="rtl"
        onDoubleClick={handleDoubleClick}
      >
        <Handle
          type="target"
          position={Position.Top}
          isConnectable={isConnectable}
          className="!bg-muted-foreground"
        />
        <div className="p-3">
          <div className="flex items-center gap-2 mb-2">
            <span className="text-xl" role="img" aria-label={typeLabels[type]}>
              {typeIcons[type]}
            </span>
            <div>
              <div className="text-xs font-medium text-muted-foreground">{typeLabels[type]}</div>
              <div className="font-medium">{label}</div>
            </div>
          </div>
          {description && <p className="text-sm text-muted-foreground">{description}</p>}
        </div>
        <Handle
          type="source"
          position={Position.Bottom}
          isConnectable={isConnectable}
          className="!bg-muted-foreground"
        />
      </Card>

      <Dialog open={isDialogOpen} onOpenChange={setIsDialogOpen}>
        <DialogContent>
          <DialogHeader>
            <DialogTitle>تحرير العنصر</DialogTitle>
          </DialogHeader>
          <div className="space-y-4">
            <div>
              <label className="text-sm font-medium">العنوان</label>
              <Input
                value={editedData.label}
                onChange={(e) => setEditedData((prev) => ({ ...prev, label: e.target.value }))}
                className="mt-1"
              />
            </div>
            <div>
              <label className="text-sm font-medium">الوصف</label>
              <Textarea
                value={editedData.description || ''}
                onChange={(e) => setEditedData((prev) => ({ ...prev, description: e.target.value }))}
                className="mt-1"
              />
            </div>
            <Button onClick={handleSave}>حفظ</Button>
          </div>
        </DialogContent>
      </Dialog>
    </>
  );
}















import { clsx, type ClassValue } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}










// pages/api/analyze.ts (Next.js API route example)
import type { NextApiRequest, NextApiResponse } from 'next';

// **IMPORTANT:** Replace with the actual Gemini API library and key setup
// For demonstration purposes, I'm using a placeholder.
const GEMINI_API_KEY = process.env.GEMINI_API_KEY; // Store securely!

interface Entity {
  name: string;
  type: string;
  confidence?: number;
}

interface GeminiResponse {
  entities: Entity[];
  error?: string;
}

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse<GeminiResponse>
) {
  if (req.method !== 'POST') {
    return res.status(405).json({ entities: [], error: 'Method Not Allowed' });
  }

  const { text } = req.body;

  if (!text) {
    return res.status(400).json({ entities: [], error: 'Text is required' });
  }

  try {
    // **Placeholder for Gemini API call:**
    // Replace this with your actual Gemini API call.
    const response = await simulateGeminiAPI(text); // Simulate API response

    if (response.error) {
      return res.status(500).json({ entities: [], error: response.error });
    }

    // Extract entities from the Gemini API response. This depends on the
    // structure of the response from the Gemini API.
    const entities: Entity[] = response.entities; // Adjust based on API response

    res.status(200).json({ entities: entities });
  } catch (error: any) {
    console.error('Error calling Gemini API:', error);
    res.status(500).json({ entities: [], error: error.message || 'Internal Server Error' });
  }
}

// **Placeholder function simulating the Gemini API response**
async function simulateGeminiAPI(text: string): Promise<GeminiResponse> {
  // Replace this with the actual Gemini API call.
  // This is just a placeholder for demonstration purposes.
  return new Promise((resolve) => {
    setTimeout(() => {
      const simulatedEntities: Entity[] = [
        { name: 'World War II', type: 'Event', confidence: 0.95 },
        { name: 'Adolf Hitler', type: 'Person', confidence: 0.98 },
        { name: 'Germany', type: 'Political', confidence: 0.9 },
      ];
      resolve({ entities: simulatedEntities });
    }, 500); // Simulate API latency
  });
}